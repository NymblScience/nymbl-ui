"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.examplesLoader = examplesLoader;

var path = _interopRequireWildcard(require("path"));

var _filter = _interopRequireDefault(require("lodash/filter"));

var _map = _interopRequireDefault(require("lodash/map"));

var _values = _interopRequireDefault(require("lodash/values"));

var _flatten = _interopRequireDefault(require("lodash/flatten"));

var _loaderUtils = _interopRequireDefault(require("loader-utils"));

var _escodegen = require("escodegen");

var _toAst = _interopRequireDefault(require("to-ast"));

var _astTypes = require("ast-types");

var _vueInbrowserCompiler = require("vue-inbrowser-compiler");

var _chunkify = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/chunkify"));

var _expandDefaultComponent = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/expandDefaultComponent"));

var _getImports = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/getImports"));

var _requireIt = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/requireIt"));

var _resolveESModule = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/resolveESModule"));

var _getComponentVueDoc = _interopRequireDefault(require("./utils/getComponentVueDoc"));

var _cleanComponentName = _interopRequireDefault(require("./utils/cleanComponentName"));

var _importCodeExampleFile = _interopRequireDefault(require("./utils/importCodeExampleFile"));

var _getScript = _interopRequireDefault(require("./utils/getScript"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Hack the react scaffolding to be able to load client
const absolutize = filepath => path.resolve(path.dirname(require.resolve('vue-styleguidist')), '../loaders/utils/client', filepath);

const REQUIRE_IN_RUNTIME_PATH = absolutize('requireInRuntime');
const EVAL_IN_CONTEXT_PATH = absolutize('evalInContext');

const JSX_COMPILER_UTILS_PATH = require.resolve('vue-inbrowser-compiler-utils');

function isVueFile(filepath) {
  return /.vue$/.test(filepath);
}

function isImport(req) {
  return !!req.importPath;
}

function _default(source) {
  const callback = this.async();
  const cb = callback ? callback : () => null;
  examplesLoader.call(this, source).then(res => cb(undefined, res));
}

async function examplesLoader(src) {
  const filePath = this.request.split('!').pop();
  let source = src;
  if (!filePath) return '';

  if (isVueFile(filePath)) {
    // if it's a vue file, the examples are in a docs block
    source = (0, _getComponentVueDoc.default)(src, filePath);
  }

  const config = this._styleguidist;
  const options = _loaderUtils.default.getOptions(this) || {};
  const {
    file,
    displayName,
    shouldShowDefaultExample,
    customLangs
  } = options;
  const cleanDisplayName = displayName ? (0, _cleanComponentName.default)(displayName) : undefined; // Replace placeholders (__COMPONENT__) with the passed-in component name

  if (shouldShowDefaultExample && source) {
    source = (0, _expandDefaultComponent.default)(source, cleanDisplayName);
  }

  const updateExample = props => {
    const p = (0, _importCodeExampleFile.default)(props, this.resourcePath, this);
    return config.updateExample ? config.updateExample(p, this.resourcePath) : p;
  }; // Load examples


  const examples = (0, _chunkify.default)(source, updateExample, customLangs);

  const getExampleLiveImports = source => (0, _getImports.default)((0, _getScript.default)(source, config.jsxInExamples)); // Find all import statements and require() calls in examples to make them
  // available in webpack context at runtime.
  // Note that we can't just use require() directly at runtime,
  // because webpack changes its name to something like __webpack__require__().


  const allCodeExamples = (0, _filter.default)(examples, {
    type: 'code'
  });
  const requiresFromExamples = allCodeExamples.reduce((requires, example) => {
    const requiresLocal = getExampleLiveImports(example.content);
    const importPath = example.settings.importpath;
    return requires.concat(importPath ? requiresLocal.map(path => ({
      importPath,
      path
    })) : requiresLocal);
  }, []); // Auto imported modules.
  // We don't need to do anything here to support explicit imports: they will
  // work because both imports (generated below and by rewrite-imports) will
  // be eventually transpiled to `var x = require('x')`, so we'll just have two
  // of them in the same scope, which is fine in non-strict mode

  const fullContext = _objectSpread({}, config.context, {}, displayName && config.jsxInExamples ? {
    [displayName]: file
  } : {}); // All required or imported modules


  const allModules = [...requiresFromExamples, ...(0, _values.default)(fullContext)]; // “Prerequire” modules required in Markdown examples and context so they
  // end up in a bundle and be available at runtime

  const allModulesCode = allModules.reduce((requires, requireRequest) => {
    // if we are looking at a remote example
    // resolve the requires from there
    if (isImport(requireRequest)) {
      if (!requires[requireRequest.importPath]) {
        requires[requireRequest.importPath] = {};
      }

      const relativePath = /^\./.test(requireRequest.path) ? path.join(requireRequest.importPath, requireRequest.path) : requireRequest.path;
      requires[requireRequest.importPath][requireRequest.path] = (0, _requireIt.default)(relativePath);
    } else {
      requires[requireRequest] = (0, _requireIt.default)(requireRequest);
    }

    return requires;
  }, {}); // Require context modules so they are available in an example

  const requireContextCode = _astTypes.builders.program((0, _flatten.default)((0, _map.default)(fullContext, _resolveESModule.default))); // Stringify examples object except the evalInContext function


  const examplesWithEval = examples.map(example => {
    if (example.type === 'code') {
      let compiled = false;

      if (config.codeSplit) {
        if (process.env.NODE_ENV === 'production') {
          // if we are not in prod, we want to avoid running examples through
          // buble all at the same time. We then tell it to calsculate on the fly
          const compiledExample = (0, _vueInbrowserCompiler.compile)(example.content, _objectSpread({}, config.compilerConfig, {}, config.jsxInExamples ? {
            jsx: '__pragma__(h)',
            objectAssign: 'concatenate'
          } : {}));
          compiled = {
            script: compiledExample.script,
            template: compiledExample.template,
            style: compiledExample.style
          };
        }
      }

      const importPath = example.settings && example.settings.importpath;
      const evalInContext = {
        toAST: () => _astTypes.builders.callExpression(_astTypes.builders.memberExpression(_astTypes.builders.identifier('evalInContext'), _astTypes.builders.identifier('bind')), [_astTypes.builders.identifier('null'), _astTypes.builders.callExpression(_astTypes.builders.memberExpression(_astTypes.builders.identifier('requireInRuntime'), _astTypes.builders.identifier('bind')), [_astTypes.builders.identifier('null'), importPath ? _astTypes.builders.literal(importPath) : _astTypes.builders.identifier('null')])])
      };
      return _objectSpread({}, example, {
        evalInContext,
        compiled
      });
    }

    return example;
  });
  return `
if (module.hot) {
	module.hot.accept([])
}
var requireMap = ${(0, _escodegen.generate)((0, _toAst.default)(allModulesCode))};
var requireInRuntimeBase = require(${JSON.stringify(REQUIRE_IN_RUNTIME_PATH)});
var requireInRuntime = requireInRuntimeBase.bind(null, requireMap);
var evalInContextBase = require(${JSON.stringify(EVAL_IN_CONTEXT_PATH)});${config.jsxInExamples ? `

var compilerUtils = require(${JSON.stringify(JSX_COMPILER_UTILS_PATH)});
var evalInContext = evalInContextBase.bind(null, 
	${JSON.stringify((0, _escodegen.generate)(requireContextCode))}, 
	compilerUtils.adaptCreateElement, compilerUtils.concatenate);` : `
var evalInContext = evalInContextBase.bind(null, 
	${JSON.stringify((0, _escodegen.generate)(requireContextCode))}, 
	null, null)`}
module.exports = ${(0, _escodegen.generate)((0, _toAst.default)(examplesWithEval))}`;
}