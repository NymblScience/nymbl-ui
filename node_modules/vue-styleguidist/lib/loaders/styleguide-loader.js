"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.pitch = pitch;

var _pick = _interopRequireDefault(require("lodash/pick"));

var _commonDir = _interopRequireDefault(require("common-dir"));

var _escodegen = require("escodegen");

var _flatten = _interopRequireDefault(require("lodash/flatten"));

var _astTypes = require("ast-types");

var _toAst = _interopRequireDefault(require("to-ast"));

var _glogg = _interopRequireDefault(require("glogg"));

var fileExistsCaseInsensitive = _interopRequireWildcard(require("react-styleguidist/lib/scripts/utils/findFileCaseInsensitive"));

var _getAllContentPages = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/getAllContentPages"));

var _getComponentFilesFromSections = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/getComponentFilesFromSections"));

var _getComponentPatternsFromSections = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/getComponentPatternsFromSections"));

var _filterComponentsWithExample = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/filterComponentsWithExample"));

var _slugger = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/slugger"));

var _requireIt = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/requireIt"));

var _resolveESModule = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/resolveESModule"));

var _getSections = _interopRequireDefault(require("./utils/getSections"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const logger = (0, _glogg.default)('vsg');
const STYLE_VARIABLE_NAME = '__vsgStyles';
const THEME_VARIABLE_NAME = '__vsgTheme'; // Config options that should be passed to the client

const CLIENT_CONFIG_OPTIONS = ['title', 'tocMode', 'version', 'showCode', 'showUsage', 'showSidebar', 'previewDelay', 'theme', 'styles', 'compilerConfig', 'editorConfig', 'ribbon', 'pagePerSection', 'mountPointId', 'jsxInExamples', 'jssThemedEditor'];

function _default() {}

function pitch(source) {
  // Clear cache so it would detect new or renamed files
  fileExistsCaseInsensitive.clearCache(); // Reset slugger for each code reload to be deterministic

  _slugger.default.reset();

  const config = this._styleguidist;
  if (!config.sections) return '';
  let sections = (0, _getSections.default)(config.sections, config);

  if (config.skipComponentsWithoutExample) {
    sections = (0, _filterComponentsWithExample.default)(sections);
  }

  const allComponentFiles = (0, _getComponentFilesFromSections.default)(config.sections, config.configDir, config.ignore);
  const allContentPages = (0, _getAllContentPages.default)(sections); // Nothing to show in the style guide

  const welcomeScreen = allContentPages.length === 0 && allComponentFiles.length === 0;
  const patterns = welcomeScreen ? (0, _getComponentPatternsFromSections.default)(config.sections) : undefined;
  const renderRootJsx = config.renderRootJsx ? (0, _requireIt.default)(config.renderRootJsx) : undefined;
  logger.debug('Loading components:\n' + allComponentFiles.join('\n')); // Setup Webpack context dependencies to enable hot reload when adding new files

  if (config.contextDependencies) {
    config.contextDependencies.forEach(dir => this.addContextDependency(dir));
  } else if (allComponentFiles.length > 0) {
    // Use common parent directory of all components as a context
    this.addContextDependency((0, _commonDir.default)(allComponentFiles));
  }

  const configClone = _objectSpread({}, config);

  const styleContext = [];

  const setVariableValueToObjectInFile = (memberName, varName) => {
    const configMember = config[memberName];

    if (typeof configMember === 'string') {
      // first attach the file as a dependency
      this.addDependency(configMember); // then create a variable to contain the value of the theme/style

      styleContext.push((0, _resolveESModule.default)(configMember, varName)); // Finally assign the calculted value to the member of the clone
      // NOTE: if we are mutating the config object without cloning it,
      // it changes the value for all hmr iteration
      // until the process is stopped.

      const variableAst = {}; // Then override the `toAST()` function, because we know
      // what the output of it should be, an identifier

      Object.defineProperty(variableAst, 'toAST', {
        enumerable: false,

        value() {
          return _astTypes.builders.identifier(varName);
        }

      });
      configClone[memberName] = variableAst;
    }
  };

  setVariableValueToObjectInFile('styles', STYLE_VARIABLE_NAME);
  setVariableValueToObjectInFile('theme', THEME_VARIABLE_NAME);
  const styleguide = {
    config: (0, _pick.default)(configClone, CLIENT_CONFIG_OPTIONS),
    welcomeScreen,
    patterns,
    sections,
    renderRootJsx
  };
  return `${(0, _escodegen.generate)(_astTypes.builders.program((0, _flatten.default)(styleContext)))}
if (module.hot) {
	module.hot.accept([])
}

module.exports = ${(0, _escodegen.generate)((0, _toAst.default)(styleguide))}
	`;
}