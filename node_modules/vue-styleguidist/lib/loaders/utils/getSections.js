"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getSections;
exports.processSection = processSection;

var fs = _interopRequireWildcard(require("fs"));

var path = _interopRequireWildcard(require("path"));

var _lodash = require("lodash");

var _requireIt = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/requireIt"));

var _getComponentFiles = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/getComponentFiles"));

var _slugger = _interopRequireDefault(require("react-styleguidist/lib/loaders/utils/slugger"));

var _getComponents = _interopRequireDefault(require("./getComponents"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// These two functions should be in the same file because of cyclic imports
const examplesLoader = path.resolve(__dirname, '../examples-loader.js');
/**
 * Return object for one level of sections.
 *
 * @param {Array} sections
 * @param {object} config
 * @param {number} parentDepth
 * @returns {Array}
 */

function getSections(sections, config, parentDepth) {
  return sections.map(section => processSection(section, config, parentDepth));
}
/**
 * Return an object for a given section with all components and subsections.
 * @param {object} section
 * @param {object} config
 * @param {number} parentDepth
 * @returns {object}
 */


function processSection(section, config, parentDepth) {
  const contentRelativePath = section.content; // Try to load section content file

  let content;

  if (contentRelativePath) {
    const contentAbsolutePath = path.resolve(config.configDir, contentRelativePath);

    if (!fs.existsSync(contentAbsolutePath)) {
      throw new Error(`Styleguidist: Section content file not found: ${contentAbsolutePath}`);
    }

    content = (0, _requireIt.default)(`!!${examplesLoader}?customLangs=vue|js|jsx!${contentAbsolutePath}`);
  }

  let sectionDepth;

  if (parentDepth === undefined) {
    sectionDepth = section.sectionDepth !== undefined ? section.sectionDepth : 0;
  } else {
    sectionDepth = parentDepth === 0 ? 0 : parentDepth - 1;
  }

  return {
    name: section.name || '',
    exampleMode: section.exampleMode || config.exampleMode,
    usageMode: section.usageMode || config.usageMode,
    sectionDepth,
    description: section.description,
    slug: _slugger.default.slug(section.name || ''),
    sections: getSections(section.sections || [], config, sectionDepth),
    filepath: contentRelativePath,
    href: section.href,
    components: getSectionComponents(section, config),
    content,
    external: section.external
  };
}

const getSectionComponents = (section, config) => {
  let ignore = config.ignore ? (0, _lodash.castArray)(config.ignore) : [];

  if (section.ignore) {
    ignore = ignore.concat((0, _lodash.castArray)(section.ignore));
  }

  return (0, _getComponents.default)((0, _getComponentFiles.default)(section.components, config.configDir, ignore), config);
};